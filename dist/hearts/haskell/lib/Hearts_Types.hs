{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Hearts_Types where
import Prelude ( Bool(..), Enum, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 return, length, IO, fromIntegral, fromEnum, toEnum,
                 (.), (&&), (||), (==), (++), ($), (-) )

import Control.Exception
import Data.ByteString.Lazy
import Data.Hashable
import Data.Int
import Data.Text.Lazy ( Text )
import qualified Data.Text.Lazy as TL
import Data.Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector

import Thrift
import Thrift.Types ()


data Suit = CLUBS|DIAMONDS|SPADES|HEARTS  deriving (Show,Eq, Typeable, Ord)
instance Enum Suit where
  fromEnum t = case t of
    CLUBS -> 21
    DIAMONDS -> 22
    SPADES -> 23
    HEARTS -> 24
  toEnum t = case t of
    21 -> CLUBS
    22 -> DIAMONDS
    23 -> SPADES
    24 -> HEARTS
    _ -> throw ThriftException
instance Hashable Suit where
  hashWithSalt salt = hashWithSalt salt . fromEnum
data Rank = ACE|TWO|THREE|FOUR|FIVE|SIX|SEVEN|EIGHT|NINE|TEN|JACK|QUEEN|KING  deriving (Show,Eq, Typeable, Ord)
instance Enum Rank where
  fromEnum t = case t of
    ACE -> 1
    TWO -> 2
    THREE -> 3
    FOUR -> 4
    FIVE -> 5
    SIX -> 6
    SEVEN -> 7
    EIGHT -> 8
    NINE -> 9
    TEN -> 10
    JACK -> 11
    QUEEN -> 12
    KING -> 13
  toEnum t = case t of
    1 -> ACE
    2 -> TWO
    3 -> THREE
    4 -> FOUR
    5 -> FIVE
    6 -> SIX
    7 -> SEVEN
    8 -> EIGHT
    9 -> NINE
    10 -> TEN
    11 -> JACK
    12 -> QUEEN
    13 -> KING
    _ -> throw ThriftException
instance Hashable Rank where
  hashWithSalt salt = hashWithSalt salt . fromEnum
data Position = NORTH|EAST|SOUTH|WEST  deriving (Show,Eq, Typeable, Ord)
instance Enum Position where
  fromEnum t = case t of
    NORTH -> 1
    EAST -> 2
    SOUTH -> 3
    WEST -> 4
  toEnum t = case t of
    1 -> NORTH
    2 -> EAST
    3 -> SOUTH
    4 -> WEST
    _ -> throw ThriftException
instance Hashable Position where
  hashWithSalt salt = hashWithSalt salt . fromEnum
data Card = Card{f_Card_suit :: Maybe Suit,f_Card_rank :: Maybe Rank} deriving (Show,Eq,Typeable)
instance Hashable Card where
  hashWithSalt salt record = salt   `hashWithSalt` f_Card_suit record   `hashWithSalt` f_Card_rank record  
write_Card oprot record = do
  writeStructBegin oprot "Card"
  case f_Card_suit record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("suit",T_I32,1)
    writeI32 oprot (fromIntegral $ fromEnum _v)
    writeFieldEnd oprot}
  case f_Card_rank record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("rank",T_I32,2)
    writeI32 oprot (fromIntegral $ fromEnum _v)
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Card_fields iprot record = do
  (_,_t3,_id4) <- readFieldBegin iprot
  if _t3 == T_STOP then return record else
    case _id4 of 
      1 -> if _t3 == T_I32 then do
        s <- (do {i <- readI32 iprot; return $ toEnum $ fromIntegral i})
        read_Card_fields iprot record{f_Card_suit=Just s}
        else do
          skip iprot _t3
          read_Card_fields iprot record
      2 -> if _t3 == T_I32 then do
        s <- (do {i <- readI32 iprot; return $ toEnum $ fromIntegral i})
        read_Card_fields iprot record{f_Card_rank=Just s}
        else do
          skip iprot _t3
          read_Card_fields iprot record
      _ -> do
        skip iprot _t3
        readFieldEnd iprot
        read_Card_fields iprot record
read_Card iprot = do
  _ <- readStructBegin iprot
  record <- read_Card_fields iprot (Card{f_Card_suit=Nothing,f_Card_rank=Nothing})
  readStructEnd iprot
  return record
data Ticket = Ticket{f_Ticket_gameId :: Maybe Text,f_Ticket_agentId :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable Ticket where
  hashWithSalt salt record = salt   `hashWithSalt` f_Ticket_gameId record   `hashWithSalt` f_Ticket_agentId record  
write_Ticket oprot record = do
  writeStructBegin oprot "Ticket"
  case f_Ticket_gameId record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("gameId",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_Ticket_agentId record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("agentId",T_STRING,2)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Ticket_fields iprot record = do
  (_,_t8,_id9) <- readFieldBegin iprot
  if _t8 == T_STOP then return record else
    case _id9 of 
      1 -> if _t8 == T_STRING then do
        s <- readString iprot
        read_Ticket_fields iprot record{f_Ticket_gameId=Just s}
        else do
          skip iprot _t8
          read_Ticket_fields iprot record
      2 -> if _t8 == T_STRING then do
        s <- readString iprot
        read_Ticket_fields iprot record{f_Ticket_agentId=Just s}
        else do
          skip iprot _t8
          read_Ticket_fields iprot record
      _ -> do
        skip iprot _t8
        readFieldEnd iprot
        read_Ticket_fields iprot record
read_Ticket iprot = do
  _ <- readStructBegin iprot
  record <- read_Ticket_fields iprot (Ticket{f_Ticket_gameId=Nothing,f_Ticket_agentId=Nothing})
  readStructEnd iprot
  return record
data EntryResponse = EntryResponse{f_EntryResponse_ticket :: Maybe Ticket,f_EntryResponse_message :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable EntryResponse where
  hashWithSalt salt record = salt   `hashWithSalt` f_EntryResponse_ticket record   `hashWithSalt` f_EntryResponse_message record  
write_EntryResponse oprot record = do
  writeStructBegin oprot "EntryResponse"
  case f_EntryResponse_ticket record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("ticket",T_STRUCT,1)
    write_Ticket oprot _v
    writeFieldEnd oprot}
  case f_EntryResponse_message record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("message",T_STRING,2)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_EntryResponse_fields iprot record = do
  (_,_t13,_id14) <- readFieldBegin iprot
  if _t13 == T_STOP then return record else
    case _id14 of 
      1 -> if _t13 == T_STRUCT then do
        s <- (read_Ticket iprot)
        read_EntryResponse_fields iprot record{f_EntryResponse_ticket=Just s}
        else do
          skip iprot _t13
          read_EntryResponse_fields iprot record
      2 -> if _t13 == T_STRING then do
        s <- readString iprot
        read_EntryResponse_fields iprot record{f_EntryResponse_message=Just s}
        else do
          skip iprot _t13
          read_EntryResponse_fields iprot record
      _ -> do
        skip iprot _t13
        readFieldEnd iprot
        read_EntryResponse_fields iprot record
read_EntryResponse iprot = do
  _ <- readStructBegin iprot
  record <- read_EntryResponse_fields iprot (EntryResponse{f_EntryResponse_ticket=Nothing,f_EntryResponse_message=Nothing})
  readStructEnd iprot
  return record
data GameInfo = GameInfo{f_GameInfo_position :: Maybe Position} deriving (Show,Eq,Typeable)
instance Hashable GameInfo where
  hashWithSalt salt record = salt   `hashWithSalt` f_GameInfo_position record  
write_GameInfo oprot record = do
  writeStructBegin oprot "GameInfo"
  case f_GameInfo_position record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("position",T_I32,1)
    writeI32 oprot (fromIntegral $ fromEnum _v)
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_GameInfo_fields iprot record = do
  (_,_t18,_id19) <- readFieldBegin iprot
  if _t18 == T_STOP then return record else
    case _id19 of 
      1 -> if _t18 == T_I32 then do
        s <- (do {i <- readI32 iprot; return $ toEnum $ fromIntegral i})
        read_GameInfo_fields iprot record{f_GameInfo_position=Just s}
        else do
          skip iprot _t18
          read_GameInfo_fields iprot record
      _ -> do
        skip iprot _t18
        readFieldEnd iprot
        read_GameInfo_fields iprot record
read_GameInfo iprot = do
  _ <- readStructBegin iprot
  record <- read_GameInfo_fields iprot (GameInfo{f_GameInfo_position=Nothing})
  readStructEnd iprot
  return record
data Trick = Trick{f_Trick_leader :: Maybe Position,f_Trick_played :: Maybe (Vector.Vector Card)} deriving (Show,Eq,Typeable)
instance Hashable Trick where
  hashWithSalt salt record = salt   `hashWithSalt` f_Trick_leader record   `hashWithSalt` f_Trick_played record  
write_Trick oprot record = do
  writeStructBegin oprot "Trick"
  case f_Trick_leader record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("leader",T_I32,1)
    writeI32 oprot (fromIntegral $ fromEnum _v)
    writeFieldEnd oprot}
  case f_Trick_played record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("played",T_LIST,2)
    (let f = Vector.mapM_ (\_viter22 -> write_Card oprot _viter22) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Trick_fields iprot record = do
  (_,_t24,_id25) <- readFieldBegin iprot
  if _t24 == T_STOP then return record else
    case _id25 of 
      1 -> if _t24 == T_I32 then do
        s <- (do {i <- readI32 iprot; return $ toEnum $ fromIntegral i})
        read_Trick_fields iprot record{f_Trick_leader=Just s}
        else do
          skip iprot _t24
          read_Trick_fields iprot record
      2 -> if _t24 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Card iprot)) in do {(_etype29,_size26) <- readListBegin iprot; f _size26})
        read_Trick_fields iprot record{f_Trick_played=Just s}
        else do
          skip iprot _t24
          read_Trick_fields iprot record
      _ -> do
        skip iprot _t24
        readFieldEnd iprot
        read_Trick_fields iprot record
read_Trick iprot = do
  _ <- readStructBegin iprot
  record <- read_Trick_fields iprot (Trick{f_Trick_leader=Nothing,f_Trick_played=Nothing})
  readStructEnd iprot
  return record
